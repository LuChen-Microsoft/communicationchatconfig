import { createDiagnosticCollector, getDeprecationDetails, getDoc, getNamespaceFullName, getSummary, isNeverType, isNullType, isVoidType, } from "@typespec/compiler";
import { getAddedOnVersions, getRemovedOnVersions, getVersions } from "@typespec/versioning";
import { createDiagnostic } from "./lib.js";
import { getCrossLanguageDefinitionId, getEffectivePayloadType, getHttpOperationWithCache, isApiVersion, } from "./public-utils.js";
/**
 *
 * @param emitterName Full emitter name
 * @returns The language of the emitter. I.e. "@azure-tools/typespec-csharp" will return "csharp"
 */
export function parseEmitterName(program, emitterName) {
    const diagnostics = createDiagnosticCollector();
    if (!emitterName) {
        diagnostics.add(createDiagnostic({
            code: "no-emitter-name",
            format: {},
            target: program.getGlobalNamespaceType(),
        }));
        return diagnostics.wrap("none");
    }
    const regex = /(?:cadl|typespec|client|server)-([^\\/-]*)/;
    const match = emitterName.match(regex);
    if (!match || match.length < 2)
        return diagnostics.wrap("none");
    const language = match[1];
    if (["typescript", "ts"].includes(language))
        return diagnostics.wrap("javascript");
    return diagnostics.wrap(language);
}
/**
 *
 * @param context
 * @param namespace If we know explicitly the namespace of the client, pass this in
 * @returns The name of the namespace
 */
export function getClientNamespaceStringHelper(context, namespace) {
    let packageName = context.packageName;
    if (packageName) {
        packageName = packageName
            .replace(/-/g, ".")
            .replace(/\.([a-z])?/g, (match) => match.toUpperCase());
        return packageName.charAt(0).toUpperCase() + packageName.slice(1);
    }
    if (namespace) {
        return getNamespaceFullName(namespace);
    }
    return undefined;
}
/**
 *
 * @param context
 * @param type The type that we are adding api version information onto
 * @returns Whether the type is the api version parameter and the default value for the client
 */
export function updateWithApiVersionInformation(context, type, namespace) {
    const isApiVersionParam = isApiVersion(context, type);
    return {
        isApiVersionParam,
        clientDefaultValue: isApiVersionParam && namespace
            ? context.__namespaceToApiVersionClientDefaultValue.get(namespace)
            : undefined,
        onClient: onClient(context, type),
    };
}
export function filterApiVersionsWithDecorators(context, type, apiVersions) {
    const addedOnVersions = getAddedOnVersions(context.program, type)?.map((x) => x.value) ?? [];
    const removedOnVersions = getRemovedOnVersions(context.program, type)?.map((x) => x.value) ?? [];
    let added = addedOnVersions.length ? false : true;
    let addedCounter = 0;
    let removeCounter = 0;
    const retval = [];
    for (let i = 0; i < apiVersions.length; i++) {
        const version = apiVersions[i];
        if (addedCounter < addedOnVersions.length && version === addedOnVersions[addedCounter]) {
            added = true;
            addedCounter++;
        }
        if (removeCounter < removedOnVersions.length && version === removedOnVersions[removeCounter]) {
            added = false;
            removeCounter++;
        }
        if (added) {
            // only add version smaller than config
            if (context.apiVersion === undefined ||
                context.apiVersion === "latest" ||
                context.apiVersion === "all" ||
                apiVersions.indexOf(context.apiVersion) >= i) {
                retval.push(version);
            }
        }
    }
    return retval;
}
function sortAndRemoveDuplicates(a, b, apiVersions) {
    const union = Array.from(new Set([...a, ...b]));
    return apiVersions.filter((item) => union.includes(item));
}
/**
 *
 * @param context
 * @param type
 * @param client If it's associated with a client, meaning it's a param etc, we can see if it's available on that client
 * @returns All api versions the type is available on
 */
export function getAvailableApiVersions(context, type, wrapper) {
    let wrapperApiVersions = [];
    if (wrapper) {
        wrapperApiVersions = context.__tspTypeToApiVersions.get(wrapper) || [];
    }
    const allApiVersions = getVersions(context.program, type)[1]
        ?.getVersions()
        .map((x) => x.value) || [];
    const apiVersions = wrapperApiVersions.length ? wrapperApiVersions : allApiVersions;
    if (!apiVersions)
        return [];
    const explicitlyDecorated = filterApiVersionsWithDecorators(context, type, apiVersions);
    if (explicitlyDecorated.length) {
        context.__tspTypeToApiVersions.set(type, explicitlyDecorated);
        return explicitlyDecorated;
    }
    // we take the union of all of the api versions that the type is available on
    // if it's called multiple times with diff wrappers, we want to make sure we have
    // all of the possible api versions listed
    const existing = context.__tspTypeToApiVersions.get(type) || [];
    const retval = sortAndRemoveDuplicates(wrapperApiVersions, existing, allApiVersions);
    context.__tspTypeToApiVersions.set(type, retval);
    return retval;
}
/**
 *
 * @param context
 * @param type
 * @returns Returns the description and details of a type
 */
export function getDocHelper(context, type) {
    const program = context.program;
    if (getSummary(program, type)) {
        return {
            description: getSummary(program, type),
            details: getDoc(program, type),
        };
    }
    return {
        description: getDoc(program, type),
    };
}
/**
 *
 * @param type
 * @returns A unique id for each type so we can do set comparisons
 */
export function getHashForType(type) {
    if (type.kind === "array" || type.kind === "dict") {
        return `${type.kind}[${getHashForType(type.valueType)}]`;
    }
    if (type.kind === "enum" || type.kind === "model" || type.kind === "enumvalue")
        return type.name;
    if (type.kind === "union") {
        return type.values.map((x) => getHashForType(x)).join("|");
    }
    return type.kind;
}
/**
 * Helper function to return default values for encode etc
 * @param type
 */
export function getSdkTypeBaseHelper(context, type, kind) {
    return {
        __raw: type,
        deprecation: getDeprecationDetails(context.program, type)?.message,
        kind,
    };
}
export function intOrFloat(value) {
    return value.toString().indexOf(".") === -1 ? "int32" : "float32";
}
/**
 * Whether a model or enum or union as enum is in Azure.Core[.Foundations] namespace
 * @param t
 * @returns
 */
export function isAzureCoreModel(t) {
    return ((t.kind === "Model" || t.kind === "Enum" || t.kind === "Union") &&
        t.namespace !== undefined &&
        ["Azure.Core", "Azure.Core.Foundations"].includes(getNamespaceFullName(t.namespace)));
}
export function isAcceptHeader(param) {
    return param.kind === "header" && param.serializedName.toLowerCase() === "accept";
}
export function isContentTypeHeader(param) {
    return param.kind === "header" && param.serializedName.toLowerCase() === "content-type";
}
export function isMultipartOperation(context, operation) {
    if (!operation)
        return false;
    const httpOperation = getHttpOperationWithCache(context, operation);
    const httpBody = httpOperation.parameters.body;
    if (httpBody && httpBody.type.kind === "Model") {
        return httpBody.contentTypes.some((x) => x.startsWith("multipart/"));
    }
    return false;
}
export function isHttpOperation(context, obj) {
    return obj?.kind === "Operation" && getHttpOperationWithCache(context, obj) !== undefined;
}
export function createTCGCContext(program) {
    return {
        program,
        emitterName: "__TCGC_INTERNAL__",
        diagnostics: [],
        originalProgram: program,
        __namespaceToApiVersionParameter: new Map(),
        __tspTypeToApiVersions: new Map(),
        __namespaceToApiVersionClientDefaultValue: new Map(),
    };
}
export function getNonNullOptions(type) {
    return [...type.variants.values()].map((x) => x.type).filter((t) => !isNullType(t));
}
export function getNullOption(type) {
    return [...type.variants.values()].map((x) => x.type).filter((t) => isNullType(t))[0];
}
export function getAllResponseBodiesAndNonBodyExists(responses) {
    const allResponseBodies = [];
    let nonBodyExists = false;
    for (const response of responses.values()) {
        if (response.type) {
            if (response.type.kind === "nullable") {
                nonBodyExists = true;
            }
            allResponseBodies.push(response.type);
        }
        else {
            nonBodyExists = true;
        }
    }
    return { allResponseBodies, nonBodyExists };
}
export function getAllResponseBodies(responses) {
    return getAllResponseBodiesAndNonBodyExists(responses).allResponseBodies;
}
/**
 * Use this if you are trying to create a generated name for something without an original TypeSpec type.
 *
 * Otherwise, you should use the `getGeneratedName` function.
 * @param context
 */
export function createGeneratedName(context, type, suffix) {
    return `${getCrossLanguageDefinitionId(context, type).split(".").at(-1)}${suffix}`;
}
function isOperationBodyType(context, type, operation) {
    if (type.kind !== "Model")
        return false;
    if (!isHttpOperation(context, operation))
        return false;
    const httpBody = operation
        ? getHttpOperationWithCache(context, operation).parameters.body
        : undefined;
    return Boolean(httpBody &&
        httpBody.type.kind === "Model" &&
        getEffectivePayloadType(context, httpBody.type) === getEffectivePayloadType(context, type));
}
export function isMultipartFormData(context, type, operation) {
    return isMultipartOperation(context, operation) && isOperationBodyType(context, type, operation);
}
export function isSubscriptionId(context, parameter) {
    return Boolean(context.arm) && parameter.name === "subscriptionId";
}
export function onClient(context, parameter) {
    return isSubscriptionId(context, parameter) || isApiVersion(context, parameter);
}
export function getLocationOfOperation(operation) {
    // have to check interface first, because interfaces are more granular than namespaces
    return (operation.interface || operation.namespace);
}
export function isNeverOrVoidType(type) {
    return isNeverType(type) || isVoidType(type);
}
export function getAnyType() {
    return {
        kind: "any",
        encode: "string",
    };
}
//# sourceMappingURL=internal-utils.js.map